<<<<<<< HEAD
<!DOCTYPE html><html><head><meta charset="UTF-8"><link rel="shortcut icon" href="../../../assets/images/favicon.ico" type="image/x-icon" /><title>Backend_NodeJs_K1/Day7</title><link rel="stylesheet" href="../../../assets/css/style.css" /></head><body><h2><a href="https://github.com/dungng1321/f8-BackEnd-NodeJS-k1/tree/feature/day-7">Nguyễn Đức Dũng</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt *</p>
<p>Cần kiểm tra tất cả các trường hợp có thể xảy ra khi làm việc với mảng:</p>
<ul>
<li>
<p>Kiểm tra đầu vào có phải là một mảng hay không? Nếu không phải là mảng cần thông báo cho hợp lý trong trường hợp này.</p>
</li>
<li>
<p>Kiểm tra trong 2 mảng đầu vào có mảng nào trống hay không? Tương tự nếu có mảng trống sẽ thông báo như nào cho hợp lý.</p>
</li>
<li>
<p>Nên tính đến trường hợp 2 mảng không có phần tử nào giống nhau thì thông báo cho người dùng biết sẽ hợp lý hơn.</p>
</li>
</ul>
<p>Hiện tại, chưa kiểm tra nếu trong <code>same</code> đã có phần tử giống nhau lần 1 rồi thì các vòng lặp sau nếu có phần tử đó sẽ không lưu kết quả vào <code>same</code> nữa. Cần sửa lại, nếu để như hiện tại thì trong <code>same</code> sẽ có những trường hợp 1 phần tử xuất hiện nhiều hơn 1 lần. Không đúng với yêu cầu bài toán.</p>
=======
<!DOCTYPE html><html><head><meta charset="UTF-8"><link rel="shortcut icon" href="../../../assets/images/favicon.ico" type="image/x-icon" /><title>Backend_NodeJs_K1/Day7</title><link rel="stylesheet" href="../../../assets/css/style.css" /></head><body><h1>Dương review bài học viên lớp K1- Backend</h1>
<p><strong>Note:</strong></p>
<hr>
<h2><a href="https://github.com/tuilahieu/nodejs/blob/main/exercise/day6/index.html">Trần Văn Hiểu</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm rất tốt *</p>
<p>Tuy nhiên cần kiểm tra điều kiện nếu mảng này là mảng rỗng thì sẽ đưa ra thông báo thích hợp.</p>
<p>Hiện tại nếu kiểm tra đầu vào là mảng rỗng thì sẽ có thông báo như sau: <code>Số nhỏ nhất trong mảng là undefined và vị trí 0</code> như vậy là vì khởi tạo biến <code>index = 0</code> nên trường hợp này nó luôn trả về index là 0 thì không hợp lý cho lắm.</p>
<p>Và nếu như mảng có 1 phần tử thì kết quả nhận được cũng không hợp lý. Cần chỉnh sửa và bổ sung.</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<<<<<<< HEAD
<p>Bài làm tốt *</p>
<p>Cần kiểm tra điều kiện đầu vào như nhận xét ở bài 1.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<p>Bài làm tốt *</p>
<p>Cần kiểm tra điều kiện đầu vào như nhận xét ở bài 1.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá: Bài làm khá tốt, tuy nhiên cần lưu ý một số điều kiện cần kiểm tra khi làm việc với mảng để hoàn thiện bài làm hơn.</li>
</ul>
<hr>
<h2><a href="https://github.com/phuongnd168/back-end-f8/tree/main/Buoi7">Phương</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt. *</p>
<p>Bài làm sử dụng phương thức <code>reduce</code> để giải quyết bài toán tuy nhiên trong điều kiện if ở trong vòng lặp reduce đang có một số vấn đề:</p>
<ul>
<li>
<p>Chưa kiểm tra là nếu phần tử <code>current</code> hiện tại đã có trong result rồi thì không push vào nữa.</p>
<pre><code class="language-js">var arr1 = [1, 5, 11, 2, 6, 6, 6, 11];
var arr2 = [6, 4, 20, 11];
//Output: Kết quả giao giữa 2 mảng là 11,6,6,6,11
</code></pre>
<p>Đề xuất:</p>
<pre><code class="language-js">if (arr2.includes(current) &amp;&amp; !prev.includes(current)) {
  prev.push(current);
}
</code></pre>
</li>
<li>
<p>Chưa tính đến trường hợp giữa 2 mảng không có phần tử nào giống nhau thì Output sẽ như thế nào cho hợp lý.</p>
<p>Đề xuất:</p>
<pre><code class="language-js">if (result.length === 0) {
  console.log(&quot;Không có phần tử giao giữa hai mảng&quot;);
} else {
  console.log(&quot;Kết quả giao giữa hai mảng là&quot;, result);
}
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<p>Bài làm tốt</p>
<p>Vì sử dụng phương thức Number đối với mảng nên khi mảng rỗng nó sẽ chuyển về số 0, điều này làm cho kết quả không đúng nếu như trong mảng đầu vào có mảng rỗng.</p>
<p>Sử dụng phương thức <code>split</code> ngăn cách các phần tử bởi dấu <code>,</code> điều này nếu như trong mảng phần tử như <code>&quot;7,8&quot;</code> thì kết quả sẽ không đúng.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<p>Bài làm tốt *</p>
<p>Bài làm chỉ đúng với trường hợp input ở ví dụ nhưng nếu trường hợp nào mà kiểu dữ liệu không phải là <code>string</code>, <code>number</code>, <code>boolean</code> thì chưa xử lý trong bài những trường hợp ngoại lệ đó.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá: Bài làm tốt nhưng cần chú ý hơn để giải quyết các trường hợp đặc biệt khi giải quyết một vấn đề nào đó.</li>
</ul>
<hr>
<h2><a href="https://github.com/NguyenNhat04/f8-backend-k1/tree/main/day-7">Nguyễn Nhất</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt. *</p>
<p>Bài làm sử dụng phương thức <code>reduce</code> để giải quyết bài toán tuy nhiên trong điều kiện if ở trong vòng lặp reduce đang có một số vấn đề:</p>
<ul>
<li>
<p>Chưa kiểm tra là nếu phần tử <code>current</code> hiện tại đã có trong result rồi thì không push vào nữa.</p>
<pre><code class="language-js">var arr1 = [1, 5, 11, 2, 6, 6, 6, 11];
var arr2 = [6, 4, 20, 11];
//Output: Kết quả giao giữa 2 mảng là 11,6,6,6,11
</code></pre>
<p>Đề xuất:</p>
<pre><code class="language-js">if (arr2.includes(current) &amp;&amp; !prev.includes(current)) {
  prev.push(current);
}
</code></pre>
</li>
<li>
<p>Chưa tính đến trường hợp giữa 2 mảng không có phần tử nào giống nhau thì Output sẽ như thế nào cho hợp lý.</p>
<p>Đề xuất:</p>
<pre><code class="language-js">if (result.length === 0) {
  console.log(&quot;Không có phần tử giao giữa hai mảng&quot;);
} else {
  console.log(&quot;Kết quả giao giữa hai mảng là&quot;, result);
}
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<p>Bài làm tốt. *</p>
<p>Hiện tại đang sử dụng phương thức <code>flat</code> để làm phẳng mảng với độ sâu là 3. Tuy nhiên nếu fix cứng độ sâu như vậy thì chỉ đúng trong trường hợp này. Nên giải quyết bài toán tổng quan nhất có thể.</p>
=======
<p>Bài làm rất tốt *</p>
<p>Cần kiểm tra số đó có là số nguyên hay không?</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<p>Bài làm rất tốt *</p>
<<<<<<< HEAD
<p>Chưa kiểm tra nếu đầu vào có một mảng rỗng thì sẽ xử lý như thế nào?</p>
=======
<p>Cần kiểm tra đầu vào đã là mảng hay chưa và đầu vào có phải là mảng rỗng hay không để chặt chẽ hơn.</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<<<<<<< HEAD
<li>[x] Đánh giá: Bài làm khá tốt, chỉ cần lưu ý kiểm tra một số trường hợp đặc biệt để hoàn thiện hơn.</li>
</ul>
<hr>
<h2><a href="https://github.com/Dangmanh2001/f8_BE_k1/tree/main/Baitapbuoi7">Đào Đăng Mạnh</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt. *</p>
<p>Bài làm sử dụng phương thức <code>reduce</code> để giải quyết bài toán tuy nhiên trong điều kiện if ở trong vòng lặp reduce đang có một số vấn đề:</p>
<ul>
<li>
<p>Chưa kiểm tra là nếu phần tử <code>current</code> hiện tại đã có trong result rồi thì không push vào nữa.</p>
<pre><code class="language-js">var arr1 = [1, 5, 11, 2, 6, 6, 6, 11];
var arr2 = [6, 4, 20, 11];
//Output: Kết quả giao giữa 2 mảng là 11,6,6,6,11
</code></pre>
<p>Đề xuất:</p>
<pre><code class="language-js">if (arr2.includes(current) &amp;&amp; !prev.includes(current)) {
  prev.push(current);
}
</code></pre>
</li>
<li>
<p>Chưa tính đến trường hợp giữa 2 mảng không có phần tử nào giống nhau thì Output sẽ như thế nào cho hợp lý.</p>
<p>Đề xuất:</p>
<pre><code class="language-js">if (result.length === 0) {
  console.log(&quot;Không có phần tử giao giữa hai mảng&quot;);
} else {
  console.log(&quot;Kết quả giao giữa hai mảng là&quot;, result);
}
</code></pre>
</li>
</ul>
=======
<li>
<p>[x] Bài 4:</p>
<p>Bài làm rất tốt *</p>
<p>Cần kiểm tra đầu vào có phải là mảng rỗng hay không để chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá: Bài làm khá tốt, tuy nhiên cần đặc biệt chú ý kiểm tra các trường hợp có thể xảy ra thì bài làm sẽ chặt chẽ hơn</li>
</ul>
<hr>
<h2><a href="https://github.com/palkma-byte/f8-backend-k1/blob/main/HW/HW6/hw06.js">Phạm Hoàng</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm chưa đạt yêu cầu là ngoài việc tìm ra số lớn nhất và nhỏ nhất trong mảng còn phải tìm ra vị trí của chúng nữa.</p>
<p>Ngoài ra bài làm chưa check một số điều kiện như có là mảng hay không? Mảng có phải là mảng rỗng hay không? Cần bổ sung.</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<p>Bài làm tốt *</p>
<<<<<<< HEAD
<p>Nếu như trong mảng có phần tử không phải là số thì khi đó sẽ có phần tử NaN khi cố gắng chuyển đổi sang số. Cần tối ưu hơn.</p>
<p>Sử dụng phương thức <code>split</code> ngăn cách các phần tử bởi dấu <code>,</code> điều này nếu như trong mảng phần tử như <code>&quot;7,8&quot;</code> thì kết quả sẽ không đúng.</p>
=======
<p>Cần kiểm tra mảng đầu vào có là mảng hay không?</p>
<p>Trong hàm kiểm tra số nguyên tố, vòng lặp biến i thì điều kiện đúng phải là <code>i &lt;= Math.sqrt(n)</code>. Vì nếu n là 9 thì cần phải xét đến 3 mới đúng.</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<<<<<<< HEAD
<p>Bài làm tốt</p>
<p>Bài làm chưa kiểm tra điều kiện của mảng đầu vào.</p>
<p>Bài làm chỉ đúng với Input như ở ví dụ nhưng cần kiểm tra hết tất cả các trường hợp có thể xảy ra như 2 mảng có thể có 1 mảng là mảng rỗng hoặc có nhiều kiểu dữ liệu khác chứ không chỉ là 3 kiểu dữ liệu <code>string</code>, <code>number</code>, <code>boolean</code>.</p>
=======
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4:</p>
<p>Bài làm tốt</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
<p>Nếu phần tử cần chèn vào lớn hơn tất cả các phần tử của mảng thì chưa có xử lý cho trường hợp này.</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<<<<<<< HEAD
<li>[x] Đánh giá: Bài làm khá tốt, chỉ cần lưu ý kiểm tra các trường hợp đặc biệt có thể xảy ra để hoàn thiện hơn.</li>
</ul>
<hr>
<h2><a href="https://github.com/maiduchien23/F8-BE/blob/main/F8_BE/f8_nodejs/homeword/day07/js/ex01.js">Mai Đức Hiền</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt. *</p>
<p>Cần kiểm tra tất cả các trường hợp có thể xảy ra khi làm việc với mảng:</p>
<ul>
<li>
<p>Kiểm tra đầu vào có phải là một mảng hay không? Nếu không phải là mảng cần thông báo cho hợp lý trong trường hợp này.</p>
</li>
<li>
<p>Kiểm tra trong 2 mảng đầu vào có mảng nào trống hay không? Tương tự nếu có mảng trống sẽ phải thông báo ra màn hình.</p>
</li>
<li>
<p>Nên tính đến trường hợp 2 mảng không có phần tử nào giống nhau thì thông báo cho người dùng biết sẽ hợp lý hơn.</p>
</li>
</ul>
<p>Hiện tại, chưa kiểm tra nếu trong <code>same</code> đã có phần tử giống nhau lần 1 rồi thì các vòng lặp sau nếu có phần tử đó sẽ không lưu kết quả vào <code>same</code> nữa. Cần sửa lại, nếu để như hiện tại thì trong <code>same</code> sẽ có những trường hợp 1 phần tử xuất hiện nhiều hơn 1 lần. Không đúng với yêu cầu bài toán.</p>
=======
<li>[x] Đánh giá: Bài làm cần chú ý vào yêu cầu đề bài để thực hiện đúng theo yêu cầu, cần chú ý để xét hết tất cả các trường hợp có thể xảy ra thì bài làm sẽ chặt chẽ hơn.</li>
</ul>
<hr>
<h2><a href="https://github.com/NguyenNhat04/f8-backend-k1/tree/main/day-6">Nguyễn Nhất</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt *</p>
<p>Tuy nhiên hiện <code>console.log</code> đang là 2 dòng đều ghi <code>số lớn nhất</code> cần sửa lại.</p>
<p>Nên thêm bước kiểm tra điều kiện đầu vào là một mảng hoặc là mảng rỗng. Hiện tại nếu là mảng rỗng thì nó sẽ hiển thị vị trí index = 0 nên không hợp lý.</p>
<p>Nếu như mảng có 1 phần tử thì kết quả nhận được cũng không hợp lý. Cần chỉnh sửa và bổ sung.</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<p>Bài làm tốt *</p>
<<<<<<< HEAD
<p>Cần kiểm tra các điều kiện của đầu vào như nhận xét ở bài 1.</p>
=======
<p>Cần kiểm tra mảng đầu vào có là mảng hay không?</p>
<p>Trong hàm kiểm tra số nguyên tố, vòng lặp biến i thì điều kiện đúng phải là <code>i &lt;= Math.sqrt(n)</code>. Vì nếu n là 9 thì cần phải xét đến 3 mới đúng.</p>
<p>Khi kiểm tra đầu vào là mảng trống thì hiển thị dòng sau đây <code>Trung bình các số nguyên tố trong mảng là: Không có số nguyên tố</code>. Cần chỉnh sửa lại.</p>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<<<<<<< HEAD
<p>Bài làm chưa tốt.</p>
<p>Bài làm chỉ đúng khi độ dài 2 mảng bằng nhau, nhưng khi độ dài 2 mảng khác nhau thì Output sẽ không đúng nữa:</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true, 3],
  [&quot;b&quot;, 2, false],
];
//Output: [['a', 'b'], [1, 2], [true, false], [3]].
=======
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4:</p>
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá: Bài làm khá tốt, chỉ cần chú ý về các trường hợp có thể xảy ra để bài làm thêm chặt chẽ hơn.</li>
</ul>
<hr>
<h2><a href="https://github.com/maiduchien23/F8-BE/blob/main/F8_BE/f8_nodejs/homeword/day06/js/ex01.js">Mai Đức Hiền</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm rất tốt *</p>
<p>Tuy nhiên cần kiểm tra xem đầu vào có phải là một mảng hay không? Nếu như mảng có 1 phần tử thì kết quả nhận được không hợp lý. Cần chỉnh sửa và bổ sung.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<p>Bài làm tốt</p>
<p>Phần hàm kiểm tra số nguyên tố cần kiểm tra điều kiện của n &lt; 2 thì sẽ trả về false chứ không phải n &lt; 0.</p>
<p>Cần kiểm tra đầu vào có phải là mảng hay không?</p>
<p>Khi kiểm tra đầu vào là mảng trống thì hiển thị dòng sau đây <code>Trung bình các số nguyên tố trong mảng là: Không có số nguyên tố</code>. Cần chỉnh sửa lại.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4:</p>
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá: Bài làm khá tốt chỉ cần lưu ý một số trường hợp có thể xảy ra để bài làm có thể chặt chẽ hơn.</li>
</ul>
<hr>
<h2><a href="https://github.com/hiusnguyen201/F8-Exercise/blob/main/Lab06/lab06.js">Nguyễn Minh Hiếu</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt *</p>
<p>Chưa kiểm tra trường hợp mảng đầu vào là mảng trống hoặc không phải là mảng.</p>
<p>Nếu như mảng có 1 phần tử thì kết quả nhận được cũng không hợp lý. Cần chỉnh sửa và bổ sung.</p>
<p>Nên khai báo biến <code>index</code> ở phạm vi global để không cần phải khai báo lại mỗi khi khởi tạo 1 function.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<p>Bài làm rất tốt *</p>
<p>Cần kiểm tra đầu vào có phải là mảng hay không?</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4:</p>
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá: Bài làm khá tốt chỉ cần lưu ý một số trường hợp có thể xảy ra để bài làm có thể chặt chẽ hơn.</li>
</ul>
<hr>
<h2><a href="https://github.com/baodepzai01/f8-back-end-k1/tree/main/BTVN/BTVNB6">Phạm Văn Bảo</a></h2>
<ul>
<li>
<p>[x] Bài 1:</p>
<p>Bài làm tốt *</p>
<p>Chưa kiểm tra trường hợp mảng đầu vào là mảng trống và không phải là mảng.</p>
<p>Nếu như mảng có 1 phần tử thì kết quả nhận được cũng không hợp lý. Cần chỉnh sửa và bổ sung.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2:</p>
<p>Bài làm rất tốt *</p>
<p>Không nên đặt tên function là integer.</p>
<p>Cần kiểm tra đầu vào có phải là mảng hay không?</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3:</p>
<p>Bài làm rất tốt *</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4:</p>
<p>Bài làm chưa tốt</p>
<p>Nên kiểm tra thêm điều kiện đầu vào có là mảng hoặc là mảng trống hay không thì sẽ chặt chẽ hơn.</p>
<p>Chưa xét đến trường hợp số cần thêm vào lớn hơn tất cả các phần tử trong mảng.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá: Bài làm tốt cần lưu ý đến điều kiện kiểm tra tất cả các trường hợp có thể xảy ra.</li>
</ul>
<h2><a href="https://github.com/phuongnd168/back-end-f8/tree/main/Buoi6">Phương</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>Math.max()</code></strong> và <strong><code>Math.min()</code></strong> để tìm giá trị lớn nhất và nhỏ nhất trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let max = Math.max(...arrInt);
let min = Math.min(...arrInt);
</code></pre>
</li>
<li>
<p>Để tìm vị trí của giá trị lớn nhất và nhỏ nhất, có thể sử dụng hàm <strong><code>indexOf()</code></strong>:</p>
<pre><code class="language-js">let positionMax = arrInt.indexOf(max);
let positionMin = arrInt.indexOf(min);
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Chưa thực hiện tính trung bình các số nguyên tố trong mảng số nguyên.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>filter()</code></strong> để lọc ra các số nguyên tố trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let arrPrime = numbers.filter((num) =&gt; {
  for (let i = 2; i &lt;= Math.sqrt(num); i++) {
    if (num % i === 0) return false;
  }
  return num &gt; 1;
});
</code></pre>
</li>
<li>
<p>Có thể sử dụng hàm <strong><code>reduce()</code></strong> để tính tổng các số nguyên tố trong mảng:</p>
<pre><code class="language-js">let sum = arrPrime.reduce((acc, curr) =&gt; acc + curr, 0);
</code></pre>
</li>
<li>
<p>Tính trung bình các số nguyên tố trong mảng:</p>
</li>
</ul>
<pre><code class="language-js">let avg = sum / arrPrime.length;
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
</code></pre>
</li>
</ul>
<hr>
<ul>
<<<<<<< HEAD
<li>[x] Đánh giá: Bài làm cần lưu ý hơn các trường hợp đặc biệt khi làm việc với mảng và cần tính đến các trường hợp có thể xảy ra để hoàn thiện hơn.</li>
</ul>
<hr>
=======
<li>
<p>[x] Bài 3</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>filter()</code></strong> để lọc các phần tử trùng nhau trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let newNumbers = numbers.filter(
  (item, index) =&gt; numbers.indexOf(item) === index
);
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Thực tế chỉ cần sau khi chèn phần tử mới vào mảng, sắp xếp lại mảng là được.</p>
<p>Chưa trả về vị trí của phần tử mới được chèn vào mảng.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt *. Tuy nhiên cần chú ý đến các trường hợp có thể xảy ra để bài làm có thể chặt chẽ hơn.</li>
</ul>
<h2><a href="https://github.com/Dangmanh2001/f8_BE_k1/tree/main/Baitapbuoi6">Đào Đăng Mạnh</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>Math.max()</code></strong> và <strong><code>Math.min()</code></strong> để tìm giá trị lớn nhất và nhỏ nhất trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let max = Math.max(...numbers);
let min = Math.min(...numbers);
</code></pre>
</li>
<li>
<p>Để tìm vị trí của giá trị lớn nhất và nhỏ nhất, có thể sử dụng hàm <strong><code>indexOf()</code></strong>:</p>
<pre><code class="language-js">let positionMax = numbers.indexOf(max);
let positionMin = numbers.indexOf(min);
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>filter()</code></strong> để lọc ra các số nguyên tố trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let arrPrime = arrInt.filter((num) =&gt; {
  for (let i = 2; i &lt;= Math.sqrt(num); i++) {
    if (num % i === 0) return false;
  }
  return num &gt; 1;
});
</code></pre>
</li>
<li>
<p>Có thể sử dụng hàm <strong><code>reduce()</code></strong> để tính tổng các số nguyên tố trong mảng:</p>
<pre><code class="language-js">let sum = arrPrime.reduce((acc, curr) =&gt; acc + curr, 0);
</code></pre>
</li>
<li>
<p>Tính trung bình các số nguyên tố trong mảng:</p>
</li>
</ul>
<pre><code class="language-js">let avg = sum / arrPrime.length;
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>filter()</code></strong> để lọc các phần tử trùng nhau trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let arrNew = arr.filter((item, index) =&gt; arr.indexOf(item) === index);
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<pre><code class="language-js">newNumbers = numbers.sort(function (a, b) {
  {
    return a - b;
  }
});
</code></pre>
<p>Có thể xóa dấu ngoặc ngọn thừa ở trước và sau <code>return</code> để code gọn hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt *. Tuy nhiên cần chú ý đến các trường hợp có thể xảy ra để bài làm có thể chặt chẽ hơn.</li>
</ul>
<h2><a href="https://github.com/wex-alacrity/F8_BE_QuangMinh/tree/main/buoi6">Quang Minh Nguyễn</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Chưa thực hiện tìm vị trí của số lớn nhất và nhỏ nhất trong mảng. Nếu mảng rỗng, đoạn code sẽ gặp lỗi.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>Math.max()</code></strong> và <strong><code>Math.min()</code></strong> để tìm giá trị lớn nhất và nhỏ nhất trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<ul>
<li>
<p>Để tìm vị trí của giá trị lớn nhất và nhỏ nhất, có thể sử dụng hàm <strong><code>indexOf()</code></strong>:</p>
<pre><code class="language-js">let positionMax = array.indexOf(array[array.length - 1]);
let positionMin = array.indexOf(array[0]);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Chưa kiểm tra xem mảng có chứa số nguyên tố hay không. Nếu mảng không chứa số nguyên tố, đoạn code sẽ gặp lỗi.</p>
<p>Trường hợp số 4 vẫn đang bị nhận là số nguyên tố.</p>
<ul>
<li>
<p>Có vẻ do trường hợp này:</p>
<pre><code class="language-js">for (let index = 2; index &lt; Math.sqrt(x); index++) {
  /*...*/
}
</code></pre>
<ul>
<li>Nên sửa lại thành:</li>
</ul>
<pre><code class="language-js">for (let index = 2; index &lt;= Math.sqrt(x); index++) {
  /*...*/
}
</code></pre>
</li>
</ul>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>filter()</code></strong> để lọc ra các số nguyên tố trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let arrPrime = arr.filter((num) =&gt; {
  for (let i = 2; i &lt;= Math.sqrt(num); i++) {
    if (num % i === 0) return false;
  }
  return num &gt; 1;
});
</code></pre>
</li>
<li>
<p>Có thể sử dụng hàm <strong><code>reduce()</code></strong> để tính tổng các số nguyên tố trong mảng:</p>
<pre><code class="language-js">let sum = arrPrime.reduce((acc, curr) =&gt; acc + curr, 0);
</code></pre>
</li>
<li>
<p>Tính trung bình các số nguyên tố trong mảng:</p>
</li>
</ul>
<pre><code class="language-js">let avg = sum / arrPrime.length;
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Có thể tối ưu hơn bằng cách sử dụng hàm <strong><code>filter()</code></strong> để lọc các phần tử trùng nhau trong mảng.</p>
<ul>
<li>
<p>Ví dụ:</p>
<pre><code class="language-js">let newArr = arr.filter((item, index) =&gt; arr.indexOf(item) === index);
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4</p>
<p>Bài làm tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
<p>Đang fix cứng với vị trí cần chèn. Gây ra rất nhiều lỗi.</p>
<pre><code class="language-js">for (var i in number) {
  if (number[i] &gt;= 8) break;
}
</code></pre>
<ul>
<li>Nếu số cần chèn là 2, kết quả sẽ là: <code>[1,  4,  7,  2, 7, 10, 16, 20]</code></li>
</ul>
<p>Thực tế chỉ cần sau khi chèn phần tử mới vào mảng, sắp xếp lại mảng là được.</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt *. Tuy nhiên cần chú ý đến các trường hợp có thể xảy ra để bài làm có thể chặt chẽ hơn.</li>
</ul>
<h2><a href="https://github.com/ducanhtranptit/F8_Homework/tree/main/Buoi6">Duc Anh Tran</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm rất tốt *</p>
<p>Chưa kiểm tra xem mảng có rỗng hay không.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt * Tốt nhất lớp *</li>
</ul>
<h2><a href="https://github.com/nguyenducthanh04/f8-backend-k1.git">Thanh Nguyễn</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Hàm <strong><code>isNum()</code></strong> chưa đúng hoàn toàn. Vòng lặp <strong>for</strong> nên bắt đầu từ <strong>i = 2</strong> và điều kiện lặp nên là <strong><code>i &lt;= Math.sqrt(n)</code></strong>.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt *</li>
</ul>
<h2><a href="https://github.com/Kpa02/F8_Backend/tree/main/BaiTapB6">Dương Trung Kiên</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm rất tốt *</p>
<p>Có thể tối ưu bằng cách sử dụng một vòng lặp duy nhất:</p>
<pre><code class="language-js">var Num = [6, 9, -10, 12, 0, 14, 20, -100];
var findMaxMin = function (arr) {
  var max = arr[0];
  var min = arr[0];
  var maxIndex;
  var minIndex;
  for (var i = 0; i &lt;= arr.length - 1; i++) {
    if (arr[i] &gt;= max) {
      max = arr[i];
      maxIndex = i;
    }
    if (arr[i] &lt; min) {
      min = arr[i];
      minIndex = i;
    }
  }
  return `Số lớn nhất là ${max} tại vị trí thứ ${maxIndex}\nSố nhỏ nhất là ${min} tại vị trí thứ ${minIndex}`;
};
console.log(findMaxMin(Num));
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng hàm <strong><code>reduce()</code></strong> để tính tổng các số nguyên tố trong mảng:</p>
<pre><code class="language-js">let sum = Num1.reduce((acc, curr) =&gt; acc + curr, 0);
</code></pre>
<ul>
<li>Tính trung bình các số nguyên tố trong mảng:</li>
</ul>
<pre><code class="language-js">let avg = sum / Num1.length;
</code></pre>
<p>Lưu ý: Nên đặt tên biến có ý nghĩa hơn.</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 3</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
</li>
</ul>
<hr>
<ul>
<li>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt *</li>
</ul>
>>>>>>> 6953841c02aa00206b08c42bcf26fb0e2269029a
<script src="../../../assets/js/pages.js" defer></script></body></html>