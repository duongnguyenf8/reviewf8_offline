<!DOCTYPE html><html><head><meta charset="UTF-8"><link rel="shortcut icon" href="../../../assets/images/favicon.ico" type="image/x-icon" /><title>Fullstack_nodeJs_K1/Day20</title><link rel="stylesheet" href="../../../assets/css/style.css" /></head><body><h1><a href="https://duong.vercel.app">Dương</a> review bài 20 lớp K1 Fullstack</h1>
<h2><a href="https://github.com/xuananh2212/js_fullstack_k1/tree/main/day20">Nguyen Xuan Tuan Anh</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể làm bằng filter sẽ dễ dàng kiểm soát và dễ hiểu hơn:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
/* Trả về 1 mảng, trong đó có các phần tử trong A và B */
var result = (function () {
  if (Array.isArray(arrA) &amp;&amp; Array.isArray(arrB))
    return [...new Set(arrA.filter((n) =&gt; arrB.includes(n)))];
  else return &quot;arrA hoặc arrB không phải mảng&quot;;
})();
console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Hoặc có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công. Vì thế các trường hợp khác check đều không tốt.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<p>Vì đây là <strong>một</strong> bài viết, thay vì sử dụng className là <code>products_items</code> thì có thể sử dụng <code>post_item</code>.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
</li>
</ul>
<hr>
<h2><a href="https://github.com/anhquan2211/F8-OFFLINE/tree/main/f8-offline-day20">Luu Anh Quan</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm rất tốt *</p>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Hoặc có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
<p>Dữ liệu tiếng anh là <strong>Data</strong>, nhiều dữ liệu thì là Lots of data. Vì vậy, Data<strong>s</strong> là sai chính tả.</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
</li>
</ul>
<hr>
<h2><a href="https://github.com/realguy010895/hunganh-f8-k1/blob/main/btvn-buoi20.js">nguyen hung anh</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể sửa lại như sau:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
var diff = arrA.reduce(function (prev, current) {
  return (
    arrB.includes(current) &amp;&amp; !prev.includes(current) &amp;&amp; prev.push(current),
    prev
  );
}, []);

console.log(diff);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Trước khi flat, phải chắc chắc đàu vào là mảng để tránh bị lỗi.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công. Vì thế các trường hợp khác check đều không tốt.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p><strong>Chưa làm</strong></p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
<p>Cần chú ý cấu trúc lại folder, làm lại bài 4.</p>
</li>
</ul>
<h2><a href="https://github.com/duonghiep416/duonghiep_f8_fullstack/tree/main/Day20">Dương Hiệp</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể sửa lại như sau:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
/* Trả về 1 mảng, trong đó có các phần tử trong A và B */
var result = (function () {
  if (Array.isArray(arrA) &amp;&amp; Array.isArray(arrB))
    return [...new Set(arrA.filter((n) =&gt; arrB.includes(n)))];
  else return &quot;arrA hoặc arrB không phải mảng&quot;;
})();
console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công. Vì thế các trường hợp khác check đều không tốt.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
</li>
</ul>
<h2><a href="https://github.com/Viethoang-Mai/MVH-fullstack-nodejs-F8-01/blob/main/Bai_tap/Bai_tap_buoi_20/js/script.js">Mai Việt Hoàng</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p><strong>Bài tập không yêu cầu <code>sort()</code></strong></p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể sửa lại như sau:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
var diff = arrA.reduce(function (prev, current) {
  return (
    arrB.includes(current) &amp;&amp; !prev.includes(current) &amp;&amp; prev.push(current),
    prev
  );
}, []);

console.log(diff);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công. Vì thế các trường hợp khác check đều không tốt.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Vì đây là một <strong>bài viết</strong>, thay vì sử dụng className là <code>item</code> thì có thể sử dụng <code>post_item</code>.</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
</li>
</ul>
<h2><a href="https://github.com/phamtuan162/phamtuan-nodejs-01/blob/main/Buoi20/js/script.js">Tuấn Phạm</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm chưa tốt</p>
<p><strong>Bài tập không yêu cầu tìm khác nhau</strong></p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[ 4, 8 ]
</code></pre>
<p>Có thể sửa lại như sau:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
/* Trả về 1 mảng, trong đó có các phần tử trong A và B */
var result = (function () {
  if (Array.isArray(arrA) &amp;&amp; Array.isArray(arrB))
    return [...new Set(arrA.filter((n) =&gt; arrB.includes(n)))];
  else return &quot;arrA hoặc arrB không phải mảng&quot;;
})();
console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm rất tốt*</p>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Vì đây là một <strong>bài viết</strong>, thay vì sử dụng className là <code>item</code> thì có thể sử dụng <code>post_item</code>.</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
</li>
</ul>
<h2><a href="https://github.com/oaiHmaN25/btvn/blob/main/day20">Hoài Nam Đỗ</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể sửa lại như sau:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];

var result = arrA.reduce(function (prev, current) {
  if (arrB.includes(current) &amp;&amp; !prev.includes(current)) prev.push(current);
  return prev;
}, []);

console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Hoặc có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công. Vì thế các trường hợp khác check đều không tốt.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p><strong>Chưa làm</strong></p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
<p>Cần chú ý format code bài 1, làm lại bài 4.</p>
</li>
</ul>
<hr>
<h2><a href="https://github.com/taminhquang13/F8_Fullstack/tree/main/BT20">Minh Quang</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể sửa lại như sau:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];

var result = arrA.reduce(function (prev, current) {
  if (arrB.includes(current) &amp;&amp; !prev.includes(current)) prev.push(current);
  return prev;
}, []);

console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Hoặc có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công. Vì thế các trường hợp khác check đều không tốt.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt*</p>
<p>Cần chú ý đặt lại tên className hợp lý hơn.</p>
<p>Vì đây là một <strong>bài viết</strong>, thay vì sử dụng className là <code>container</code> thì có thể sử dụng <code>post_item</code>.</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
</li>
</ul>
<hr>
<h2><a href="https://github.com/QuocAnh-bit/F8_fullstack_006.git">Dương Quốc Anh</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể làm bằng filter sẽ dễ dàng kiểm soát và dễ hiểu hơn:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
/* Trả về 1 mảng, trong đó có các phần tử trong A và B */
var result = (function () {
  if (Array.isArray(arrA) &amp;&amp; Array.isArray(arrB))
    return [...new Set(arrA.filter((n) =&gt; arrB.includes(n)))];
  else return &quot;arrA hoặc arrB không phải mảng&quot;;
})();
console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Việc khai báo như vậy quá thủ công. Vì thế các trường hợp khác check đều không tốt.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Bài làm rất tốt *</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<p>Vì đây là <strong>một</strong> bài viết, thay vì sử dụng className là <code>item</code> thì có thể sử dụng <code>post_item</code>.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
</li>
</ul>
<hr>
<h2><a href="https://github.com/Trungdeptraii/09-08-2023-Le-Van_Trung-Day20.git">Trung Le</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể làm bằng filter sẽ dễ dàng kiểm soát và dễ hiểu hơn:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
/* Trả về 1 mảng, trong đó có các phần tử trong A và B */
var result = (function () {
  if (Array.isArray(arrA) &amp;&amp; Array.isArray(arrB))
    return [...new Set(arrA.filter((n) =&gt; arrB.includes(n)))];
  else return &quot;arrA hoặc arrB không phải mảng&quot;;
})();
console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Hoặc có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Đặt tên biến quá ẩu, không nên đặt như vậy sẽ gây khó hiểu với tất cả người đọc khác.</p>
<p>Đang hiểu sai ý đề bài, bài làm chỉ đúng khi thứ tự các phần tử đúng như bài tập.</p>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p>Bài làm tốt</p>
<p>Thuộc tính alt của một bài viết cần có ý nghĩa, có thể sử dụng heading của bài viết.</p>
<p>Chưa thiết kế được array.</p>
<p>Việc đổ dữ liệu với <code>${arr[index][2]}</code>, <code>&quot;${arr[index][1]}</code>, <code>${arr[index][0] + (+index + 1)}</code> quá khó hiểu, chỉ đúng ở trường hợp này. Với cấu trúc mảng thay đổi, toàn bộ bài đều sẽ sai.</p>
<p>Nên thiết kế một mảng lồng object với các key, value tường minh hơn, sử dụng map để lặp.</p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm tốt, cần chú ý các biến số, sai số khi dữ liệu thay đổi, bài tập hiện chỉ đúng với 1 trường hợp.</p>
</li>
</ul>
<hr>
<h2><a href="https://github.com/pth2003/FullStack_Nodejs_K1/tree/main/BTVN/btvn_buoi_20">Phan Trung Hiếu</a></h2>
<ul>
<li>
<p>[x] Bài 1</p>
<p>Bài làm tốt *</p>
<p>Với giao giữa 2 mảng, không nên có các phần tử trùng nhau.</p>
<p>Khi có cấu trúc array như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
</code></pre>
<p>Kết quả sẽ là:</p>
<pre><code class="language-shell">[1, 3, 2, 5, 3, 6, 1];
</code></pre>
<p>Có thể làm bằng filter sẽ dễ dàng kiểm soát và dễ hiểu hơn:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];
/* Trả về 1 mảng, trong đó có các phần tử trong A và B */
var result = (function () {
  if (Array.isArray(arrA) &amp;&amp; Array.isArray(arrB))
    return [...new Set(arrA.filter((n) =&gt; arrB.includes(n)))];
  else return &quot;arrA hoặc arrB không phải mảng&quot;;
})();
console.log(result);
</code></pre>
<p>Hoặc sử dùng reduce như này:</p>
<pre><code class="language-js">var arrA = [1, 4, 3, 2, 5, 3, 6, 8, 1];
var arrB = [5, 2, 6, 7, 1, 3];

var result = arrA.reduce(function (prev, current) {
  if (arrB.includes(current) &amp;&amp; !prev.includes(current)) prev.push(current);
  return prev;
}, []);
console.log(result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 2</p>
<p>Bài làm rất tốt *</p>
<p>Có thể sử dụng vòng lặp <code>while</code> để chương trình chạy tốt hơn.</p>
<p>Hoặc có thể tham khảo phương thức <code>flat</code> sẽ trả về một mảng mới đã được làm phẳng.</p>
<p>Tham số truyền vào cho phương thức này là độ sâu tối đa mà nó sẽ làm phẳng mảng.</p>
<p>Trong trường hợp này, nếu muốn làm phẳng mảng đến cấp độ tối đa nên truyền vào giá trị <code>Infinity</code>.</p>
<pre><code class="language-js">var arr = [0, 1, [2, 3], [4, 5, [6, 7]], [8, [9, 10, [11, 12]]]];

var result = (function () {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else &quot;arr không phải mảng&quot;;
})();

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 3</p>
<p>Bài làm tốt*</p>
<p>Bài làm chỉ đúng ở duy nhất 1 trường hợp khi tất cả các type được sắp xếp giống nhau ở index.</p>
<p>Nếu như đổi chỗ các giá trị, bài làm sai hoàn toàn.</p>
<pre><code class="language-js">var arr = [
  [1, &quot;a&quot;, true],
  [&quot;b&quot;, 2, false],
];
</code></pre>
<p>Có thể tham khảo một cách khác lấy thẳng type làm value</p>
<pre><code class="language-js">var arr = [
  [&quot;a&quot;, 1, true],
  [&quot;b&quot;, 2, false],
  [null, undefined, function () {}],
  [[], null, undefined, function () {}],
];
const result = (function (arr) {
  if (Array.isArray(arr)) {
    return arr.flat(Infinity).reduce((acc, item) =&gt; {
      const type = typeof item;
      if (!acc[type]) acc[type] = [];
      acc[type].push(item);
      return acc;
    }, {});
  } else return &quot;không phải mảng.&quot;;
})(arr);

console.log(&quot;result&quot;, result);
</code></pre>
<hr>
</li>
<li>
<p>[x] Bài 4</p>
<p><strong>CHƯA LÀM</strong></p>
<hr>
</li>
<li>
<p>[x] Đánh giá chung bài tập về nhà: Bài làm rất tốt, có thể sử dụng một số phương thức cho trước hoặc các phương thức đơn giản hơn để làm bài một cách dễ hiểu hơn.</p>
<p>Cần chú ý làm bài 4, chú ý đến các trường hợp khác nhau, trường hợp đặc biệt, với bài 3, chỉ đúng ở duy nhất 1 trường hợp.</p>
</li>
</ul>
<hr>
<script src="../../../assets/js/pages.js" defer></script></body></html>